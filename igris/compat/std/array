#ifndef IGRIS_STD_ARRAY_H
#define IGRIS_STD_ARRAY_H
#include "igris_std_config.hpp"

#include <cstddef>

#include "algorithm"
#include "initializer_list"
#include "utility"

namespace IGRIS_STD_NS
{
    template <typename T, size_t N> struct array
    {
        using value_type = T;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using reference = value_type &;
        using const_reference = const value_type &;
        using pointer = value_type *;
        using const_pointer = const value_type *;
        using iterator = pointer;
        using const_iterator = const_pointer;

        value_type arr[N];

        array() = default;

        array(const array &oth)
        {
            IGRIS_STD_NS::copy(oth.begin(), oth.end(), begin());
        }

        array(const IGRIS_STD_NS::initializer_list<T> &oth)
        {
            IGRIS_STD_NS::copy(oth.begin(), oth.end(), begin());
        }

        reference operator[](size_type i)
        {
            return arr[i];
        }
        const_reference operator[](size_type i) const
        {
            return arr[i];
        }

        reference front()
        {
            return arr[0];
        }

        const_reference front() const
        {
            return arr[0];
        }

        reference back()
        {
            return arr[N - 1];
        }

        const_reference back() const
        {
            return arr[N - 1];
        }

        pointer begin()
        {
            return arr;
        }
        const_iterator begin() const
        {
            return arr;
        }
        const_iterator cbegin() const
        {
            return arr;
        }
        pointer end()
        {
            return arr + N;
        }
        const_iterator end() const
        {
            return arr + N;
        }

        const_iterator cend() const
        {
            return arr + N;
        }

        pointer data()
        {
            return arr;
        }
        const_pointer data() const
        {
            return arr;
        }

        constexpr size_type size() const
        {
            return N;
        }

        constexpr size_type max_size() const
        {
            return N;
        }

        constexpr bool empty() const
        {
            return N == 0;
        }

        void fill(const T &val)
        {
            IGRIS_STD_NS::fill(begin(), end(), val);
        }

        void swap(array &oth)
        {
            IGRIS_STD_NS::swap_ranges(begin(), end(), oth.begin());
        }
    };
}

#endif
