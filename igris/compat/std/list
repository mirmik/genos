#ifndef IGRIS_STD_LIST_H
#define IGRIS_STD_LIST_H
#include "igris_std_config.hpp"

#include <cstddef>

#include <igris/container/dlist.h>
#include <igris/util/ctrdtr.h>

#include "iterator_base_types.h"
#include "memory"
#include "type_traits"
#include "utility"

namespace IGRIS_STD_NS
{
    namespace detail
    {
        template <class T> class list_node
        {
        public:
            igris::dlist_node head = {};
            T data = {};

        public:
            list_node() {}

            template <class... Args>
            explicit list_node(Args &&... args)
                : data(IGRIS_STD_NS::forward<Args>(args)...)
            {
            }

            T &value()
            {
                return data;
            }
            const T &value() const
            {
                return data;
            }

            igris::dlist_node *get_head()
            {
                return &head;
            }
            const igris::dlist_node *get_head() const
            {
                return &head;
            }
        };

        template <class T, bool IsConst> class list_iterator
        {
            using node_type = list_node<T>;
            using pointer = typename IGRIS_STD_NS::conditional<IsConst,
                                                            const T *,
                                                            T *>::type;
            using reference = typename IGRIS_STD_NS::conditional<IsConst,
                                                              const T &,
                                                              T &>::type;

            igris::dlist_node *link = nullptr;

        public:
            using iterator_category = IGRIS_STD_NS::bidirectional_iterator_tag;
            using value_type = T;
            using difference_type = ptrdiff_t;
            using pointer_type = pointer;
            using reference_type = reference;

            list_iterator() = default;
            explicit list_iterator(igris::dlist_node *node) : link(node) {}

            template <bool B = IsConst,
                      typename IGRIS_STD_NS::enable_if<B, int>::type = 0>
            list_iterator(const list_iterator<T, false> &other)
                : link(other.base())
            {
            }

            list_iterator &operator++()
            {
                link = link->next_node();
                return *this;
            }

            list_iterator operator++(int)
            {
                list_iterator tmp = *this;
                ++(*this);
                return tmp;
            }

            list_iterator &operator--()
            {
                link = link->prev_node();
                return *this;
            }

            list_iterator operator--(int)
            {
                list_iterator tmp = *this;
                --(*this);
                return tmp;
            }

            reference operator*() const
            {
                return node()->value();
            }

            pointer operator->() const
            {
                return &node()->value();
            }

            bool operator==(const list_iterator &other) const
            {
                return link == other.link;
            }

            bool operator!=(const list_iterator &other) const
            {
                return link != other.link;
            }

            igris::dlist_node *base() const
            {
                return link;
            }

        private:
            node_type *node() const
            {
                return member_container<node_type>(link, &node_type::head);
            }
        };
    } // namespace detail

    template <class T, class Alloc = IGRIS_STD_NS::allocator<detail::list_node<T>>>
    class list
    {
    public:
        using value_type = T;
        using iterator = detail::list_iterator<T, false>;
        using const_iterator = detail::list_iterator<T, true>;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using allocator_type = Alloc;
        using reference = value_type &;
        using const_reference = const value_type &;
        using pointer = value_type *;
        using const_pointer = const value_type *;

    private:
        using node_type = detail::list_node<T>;

        igris::dlist<node_type, &node_type::head> nodes;
        Alloc alloc = {};
        size_type m_size = 0;

    public:
        list() = default;
        list(const list &) = delete;
        list &operator=(const list &) = delete;

        ~list()
        {
            clear();
        }

        bool empty() const noexcept
        {
            return m_size == 0;
        }

        size_type size() const noexcept
        {
            return m_size;
        }

        iterator begin() noexcept
        {
            return iterator(nodes.begin().current);
        }

        const_iterator begin() const noexcept
        {
            return const_iterator(nodes.begin().current);
        }

        const_iterator cbegin() const noexcept
        {
            return begin();
        }

        iterator end() noexcept
        {
            return iterator(nodes.end().current);
        }

        const_iterator end() const noexcept
        {
            return const_iterator(nodes.end().current);
        }

        const_iterator cend() const noexcept
        {
            return end();
        }

        void push_back(const T &data)
        {
            insert_internal(end(), data);
        }

        void push_back(T &&data)
        {
            insert_internal(end(), IGRIS_STD_NS::move(data));
        }

        reference back()
        {
            auto it = end();
            --it;
            return *it;
        }

        const_reference back() const
        {
            auto it = end();
            --it;
            return *it;
        }

        void pop_back()
        {
            auto it = end();
            --it;
            erase(it);
        }

        void push_front(const T &data)
        {
            insert_internal(begin(), data);
        }

        void push_front(T &&data)
        {
            insert_internal(begin(), IGRIS_STD_NS::move(data));
        }

        reference front()
        {
            return *begin();
        }

        const_reference front() const
        {
            return *begin();
        }

        void pop_front()
        {
            erase(begin());
        }

        iterator insert(const_iterator pos, const T &value)
        {
            return insert_internal(pos, value);
        }

        iterator insert(const_iterator pos, T &&value)
        {
            return insert_internal(pos, IGRIS_STD_NS::move(value));
        }

        iterator erase(const_iterator pos)
        {
            auto *current = pos.base();
            auto *next = current->next_node();
            node_type *node = member_container<node_type>(current, &node_type::head);
            node->get_head()->unlink();
            igris::destructor(node);
            alloc.deallocate(node, 1);
            --m_size;
            return iterator(next);
        }

        void clear()
        {
            while (!empty())
            {
                pop_back();
            }
        }

    private:
        template <class U> iterator insert_internal(const_iterator pos, U &&value)
        {
            node_type *node = alloc.allocate(1);
            igris::constructor(node, IGRIS_STD_NS::forward<U>(value));
            nodes.move_prev(*node, pos.base());
            ++m_size;
            return iterator(node->get_head());
        }
    };
}

#endif
