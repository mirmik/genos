#ifndef IGRIS_STD_UNORDERED_MAP_H
#define IGRIS_STD_UNORDERED_MAP_H
#include "igris_std_config.hpp"

#include <cstddef>
#include <new>
#include "functional"
#include "initializer_list"
#include "memory"
#include "iterator"
#include "stdexcept"
#include "utility"

namespace IGRIS_STD_NS
{
    template <class Key,
              class T,
              class Hash = IGRIS_STD_NS::hash<Key>,
              class KeyEqual = IGRIS_STD_NS::equal_to<Key>,
              class Allocator = IGRIS_STD_NS::allocator<IGRIS_STD_NS::pair<const Key, T>>>
    class unordered_map
    {
    public:
        using key_type = Key;
        using mapped_type = T;
        using value_type = IGRIS_STD_NS::pair<const Key, T>;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using hasher = Hash;
        using key_equal = KeyEqual;
        using allocator_type = Allocator;
        using reference = value_type &;
        using const_reference = const value_type &;
        using pointer = value_type *;
        using const_pointer = const value_type *;

    private:
        struct node
        {
            value_type value;
            node *next = nullptr;

            template <class... Args>
            node(Args &&... args) : value(IGRIS_STD_NS::forward<Args>(args)...), next(nullptr)
            {
            }
        };

        using node_allocator = IGRIS_STD_NS::allocator<node>;
        using bucket_allocator = IGRIS_STD_NS::allocator<node *>;

        node **m_buckets = nullptr;
        size_t m_bucket_count = 0;
        size_t m_size = 0;
        float m_max_load_factor = 1.0f;
        hasher m_hash = {};
        key_equal m_equal = {};
        allocator_type m_alloc = {};
        node_allocator m_node_alloc = {};
        bucket_allocator m_bucket_alloc = {};

    public:
        class iterator
        {
            friend class unordered_map;
            unordered_map *m_owner = nullptr;
            size_t m_bucket = 0;
            node *m_node = nullptr;

            iterator(unordered_map *owner, size_t bucket, node *ptr)
                : m_owner(owner), m_bucket(bucket), m_node(ptr)
            {
            }

            void advance()
            {
                if (m_owner == nullptr)
                    return;

                if (m_node)
                    m_node = m_node->next;

                while (m_node == nullptr && m_bucket + 1 < m_owner->m_bucket_count)
                {
                    ++m_bucket;
                    m_node = m_owner->m_buckets[m_bucket];
                }

                if (m_node == nullptr)
                {
                    m_bucket = m_owner->m_bucket_count;
                }
            }

        public:
            using iterator_category = IGRIS_STD_NS::forward_iterator_tag;
            using value_type = unordered_map::value_type;
            using difference_type = unordered_map::difference_type;
            using pointer = unordered_map::pointer;
            using reference = unordered_map::reference;

            iterator() = default;

            reference operator*() const
            {
                return m_node->value;
            }

            pointer operator->() const
            {
                return &m_node->value;
            }

            iterator &operator++()
            {
                advance();
                return *this;
            }

            iterator operator++(int)
            {
                iterator tmp = *this;
                advance();
                return tmp;
            }

            bool operator==(const iterator &other) const
            {
                return m_owner == other.m_owner && m_bucket == other.m_bucket &&
                       m_node == other.m_node;
            }

            bool operator!=(const iterator &other) const
            {
                return !(*this == other);
            }
        };

        class const_iterator
        {
            friend class unordered_map;
            const unordered_map *m_owner = nullptr;
            size_t m_bucket = 0;
            const node *m_node = nullptr;

            const_iterator(const unordered_map *owner, size_t bucket, const node *ptr)
                : m_owner(owner), m_bucket(bucket), m_node(ptr)
            {
            }

            void advance()
            {
                if (m_owner == nullptr)
                    return;

                if (m_node)
                    m_node = m_node->next;

                while (m_node == nullptr && m_bucket + 1 < m_owner->m_bucket_count)
                {
                    ++m_bucket;
                    m_node = m_owner->m_buckets[m_bucket];
                }

                if (m_node == nullptr)
                {
                    m_bucket = m_owner->m_bucket_count;
                }
            }

        public:
            using iterator_category = IGRIS_STD_NS::forward_iterator_tag;
            using value_type = unordered_map::value_type;
            using difference_type = unordered_map::difference_type;
            using pointer = unordered_map::const_pointer;
            using reference = unordered_map::const_reference;

            const_iterator() = default;

            const_iterator(const iterator &it)
                : m_owner(it.m_owner), m_bucket(it.m_bucket), m_node(it.m_node)
            {
            }

            reference operator*() const
            {
                return m_node->value;
            }

            pointer operator->() const
            {
                return &m_node->value;
            }

            const_iterator &operator++()
            {
                advance();
                return *this;
            }

            const_iterator operator++(int)
            {
                const_iterator tmp = *this;
                advance();
                return tmp;
            }

            bool operator==(const const_iterator &other) const
            {
                return m_owner == other.m_owner && m_bucket == other.m_bucket &&
                       m_node == other.m_node;
            }

            bool operator!=(const const_iterator &other) const
            {
                return !(*this == other);
            }
        };

        unordered_map()
        {
            initialize_buckets(8);
        }

        explicit unordered_map(size_t bucket_count,
                               const Hash &hash = Hash(),
                               const KeyEqual &equal = KeyEqual(),
                               const Allocator &alloc = Allocator())
            : m_hash(hash), m_equal(equal), m_alloc(alloc)
        {
            if (bucket_count == 0)
                bucket_count = 1;
            initialize_buckets(bucket_count);
        }

        unordered_map(IGRIS_STD_NS::initializer_list<value_type> init)
        {
            initialize_buckets(init.size() == 0 ? 8 : init.size() * 2);
            for (const auto &value : init)
            {
                insert(value);
            }
        }

        unordered_map(const unordered_map &other)
            : m_hash(other.m_hash),
              m_equal(other.m_equal),
              m_alloc(other.m_alloc)
        {
            initialize_buckets(other.m_bucket_count);
            for (const auto &value : other)
            {
                insert(value);
            }
        }

        unordered_map(unordered_map &&other)
            : m_buckets(other.m_buckets),
              m_bucket_count(other.m_bucket_count),
              m_size(other.m_size),
              m_max_load_factor(other.m_max_load_factor),
              m_hash(other.m_hash),
              m_equal(other.m_equal),
              m_alloc(other.m_alloc)
        {
            other.m_buckets = nullptr;
            other.m_bucket_count = 0;
            other.m_size = 0;
        }

        unordered_map &operator=(const unordered_map &other)
        {
            if (this == &other)
                return *this;

            clear();
            free_buckets();
            m_hash = other.m_hash;
            m_equal = other.m_equal;
            m_alloc = other.m_alloc;
            m_max_load_factor = other.m_max_load_factor;
            initialize_buckets(other.m_bucket_count);
            for (const auto &value : other)
            {
                insert(value);
            }
            return *this;
        }

        unordered_map &operator=(unordered_map &&other)
        {
            if (this == &other)
                return *this;

            clear();
            free_buckets();

            m_buckets = other.m_buckets;
            m_bucket_count = other.m_bucket_count;
            m_size = other.m_size;
            m_max_load_factor = other.m_max_load_factor;
            m_hash = other.m_hash;
            m_equal = other.m_equal;
            m_alloc = other.m_alloc;

            other.m_buckets = nullptr;
            other.m_bucket_count = 0;
            other.m_size = 0;
            return *this;
        }

        ~unordered_map()
        {
            clear();
            free_buckets();
        }

        allocator_type get_allocator() const
        {
            return m_alloc;
        }

        bool empty() const
        {
            return m_size == 0;
        }

        size_type size() const
        {
            return m_size;
        }

        iterator begin()
        {
            for (size_t i = 0; i < m_bucket_count; ++i)
            {
                if (m_buckets[i])
                    return iterator(this, i, m_buckets[i]);
            }
            return end();
        }

        const_iterator begin() const
        {
            return cbegin();
        }

        const_iterator cbegin() const
        {
            for (size_t i = 0; i < m_bucket_count; ++i)
            {
                if (m_buckets[i])
                    return const_iterator(this, i, m_buckets[i]);
            }
            return cend();
        }

        iterator end()
        {
            return iterator(this, m_bucket_count, nullptr);
        }

        const_iterator end() const
        {
            return cend();
        }

        const_iterator cend() const
        {
            return const_iterator(this, m_bucket_count, nullptr);
        }

        void clear()
        {
            if (m_buckets == nullptr)
                return;

            for (size_t i = 0; i < m_bucket_count; ++i)
            {
                node *ptr = m_buckets[i];
                while (ptr)
                {
                    node *next = ptr->next;
                    destroy_node(ptr);
                    ptr = next;
                }
                m_buckets[i] = nullptr;
            }
            m_size = 0;
        }

        IGRIS_STD_NS::pair<iterator, bool> insert(const value_type &value)
        {
            ensure_capacity(m_size + 1);
            return emplace_impl(value);
        }

        IGRIS_STD_NS::pair<iterator, bool> insert(value_type &&value)
        {
            ensure_capacity(m_size + 1);
            return emplace_impl(IGRIS_STD_NS::move(value));
        }

        template <class... Args>
        IGRIS_STD_NS::pair<iterator, bool> emplace(Args &&... args)
        {
            ensure_capacity(m_size + 1);
            return emplace_impl(IGRIS_STD_NS::forward<Args>(args)...);
        }

        iterator find(const key_type &key)
        {
            auto result = find_node(key);
            if (result.first)
                return iterator(this, result.second, result.first);
            return end();
        }

        const_iterator find(const key_type &key) const
        {
            auto result = find_node(key);
            if (result.first)
                return const_iterator(this, result.second, result.first);
            return cend();
        }

        mapped_type &operator[](const key_type &key)
        {
            auto it = find(key);
            if (it != end())
            {
                return it->second;
            }

            auto inserted = emplace(key, mapped_type());
            return inserted.first->second;
        }

        mapped_type &operator[](key_type &&key)
        {
            auto it = find(key);
            if (it != end())
            {
                return it->second;
            }

            auto inserted = emplace(IGRIS_STD_NS::move(key), mapped_type());
            return inserted.first->second;
        }

        mapped_type &at(const key_type &key)
        {
            auto it = find(key);
            if (it == end())
                throw IGRIS_STD_NS::out_of_range("unordered_map::at");
            return it->second;
        }

        const mapped_type &at(const key_type &key) const
        {
            auto it = find(key);
            if (it == cend())
                throw IGRIS_STD_NS::out_of_range("unordered_map::at");
            return it->second;
        }

        size_type erase(const key_type &key)
        {
            if (m_bucket_count == 0)
                return 0;

            size_t idx = bucket_index(key);
            node *prev = nullptr;
            node *ptr = m_buckets[idx];
            while (ptr)
            {
                if (m_equal(ptr->value.first, key))
                {
                    if (prev)
                        prev->next = ptr->next;
                    else
                        m_buckets[idx] = ptr->next;
                    destroy_node(ptr);
                    --m_size;
                    return 1;
                }
                prev = ptr;
                ptr = ptr->next;
            }
            return 0;
        }

        iterator erase(const_iterator position)
        {
            if (position.m_owner != this || position.m_node == nullptr)
                return end();

            size_t idx = position.m_bucket;
            node *prev = nullptr;
            node *ptr = m_buckets[idx];
            while (ptr && ptr != position.m_node)
            {
                prev = ptr;
                ptr = ptr->next;
            }

            if (ptr == nullptr)
                return end();

            node *next = ptr->next;
            if (prev)
                prev->next = next;
            else
                m_buckets[idx] = next;

            destroy_node(ptr);
            --m_size;

            if (next)
                return iterator(this, idx, next);

            for (size_t i = idx + 1; i < m_bucket_count; ++i)
            {
                if (m_buckets[i])
                    return iterator(this, i, m_buckets[i]);
            }
            return end();
        }

        size_type bucket_count() const
        {
            return m_bucket_count;
        }

        float load_factor() const
        {
            if (m_bucket_count == 0)
                return 0.0f;
            return static_cast<float>(m_size) / static_cast<float>(m_bucket_count);
        }

        float max_load_factor() const
        {
            return m_max_load_factor;
        }

        void max_load_factor(float value)
        {
            if (value <= 0)
                value = 1.0f;
            m_max_load_factor = value;
            ensure_capacity(m_size);
        }

        void reserve(size_t count)
        {
            size_t desired = static_cast<size_t>(count / m_max_load_factor) + 1;
            if (desired > m_bucket_count)
                rehash(desired);
        }

        void rehash(size_t new_bucket_count)
        {
            if (new_bucket_count == 0)
                new_bucket_count = 1;
            node **old_buckets = m_buckets;
            size_t old_count = m_bucket_count;
            initialize_buckets(new_bucket_count);
            m_size = 0;
            if (old_buckets)
            {
                for (size_t i = 0; i < old_count; ++i)
                {
                    node *ptr = old_buckets[i];
                    while (ptr)
                    {
                        node *next = ptr->next;
                        size_t idx = bucket_index(ptr->value.first);
                        ptr->next = m_buckets[idx];
                        m_buckets[idx] = ptr;
                        ++m_size;
                        ptr = next;
                    }
                }
                m_bucket_alloc.deallocate(old_buckets, old_count);
            }
        }

    private:
        void initialize_buckets(size_t count)
        {
            if (count == 0)
                count = 1;
            m_buckets = m_bucket_alloc.allocate(count);
            for (size_t i = 0; i < count; ++i)
                m_buckets[i] = nullptr;
            m_bucket_count = count;
        }

        void free_buckets()
        {
            if (m_buckets)
            {
                m_bucket_alloc.deallocate(m_buckets, m_bucket_count);
                m_buckets = nullptr;
                m_bucket_count = 0;
            }
        }

        template <class... Args>
        IGRIS_STD_NS::pair<iterator, bool> emplace_impl(Args &&... args)
        {
            node *tmp = create_node(IGRIS_STD_NS::forward<Args>(args)...);
            size_t idx = bucket_index(tmp->value.first);
            node *ptr = m_buckets[idx];
            while (ptr)
            {
                if (m_equal(ptr->value.first, tmp->value.first))
                {
                    destroy_node(tmp);
                    return {iterator(this, idx, ptr), false};
                }
                ptr = ptr->next;
            }
            tmp->next = m_buckets[idx];
            m_buckets[idx] = tmp;
            ++m_size;
            return {iterator(this, idx, tmp), true};
        }

        template <class... Args>
        node *create_node(Args &&... args)
        {
            node *n = m_node_alloc.allocate(1);
            new (n) node(IGRIS_STD_NS::forward<Args>(args)...);
            return n;
        }

        void destroy_node(node *n)
        {
            n->~node();
            m_node_alloc.deallocate(n, 1);
        }

        void ensure_capacity(size_t desired)
        {
            if (m_bucket_count == 0)
            {
                initialize_buckets(8);
            }

            while (static_cast<float>(desired) / static_cast<float>(m_bucket_count) >
                   m_max_load_factor)
            {
                rehash(m_bucket_count * 2);
            }
        }

        size_t bucket_index(const key_type &key) const
        {
            return m_bucket_count == 0 ? 0 : (m_hash(key) % m_bucket_count);
        }

        IGRIS_STD_NS::pair<node *, size_t> find_node(const key_type &key) const
        {
            if (m_bucket_count == 0)
                return {nullptr, 0};
            size_t idx = bucket_index(key);
            node *ptr = m_buckets[idx];
            while (ptr)
            {
                if (m_equal(ptr->value.first, key))
                    return {ptr, idx};
                ptr = ptr->next;
            }
            return {nullptr, idx};
        }
    };
}

#endif
