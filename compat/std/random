#ifndef IGRIS_STD_RANDOM_H
#define IGRIS_STD_RANDOM_H
#include "igris_std_config.hpp"
#include <cstdlib>

namespace IGRIS_STD_NS
{
    template <class T> class uniform_int_distribution
    {
        T a;
        T b;

    public:
        uniform_int_distribution(T a, T b) : a(a), b(b) {}
        T operator()()
        {
            T lo = a;
            T hi = b;
            if (hi < lo)
            {
                T tmp = lo;
                lo = hi;
                hi = tmp;
            }

            const T span = hi - lo + 1;
            if (span <= 0)
                return lo;

            return lo + static_cast<T>(::rand() % span);
        }
    };

    template <class T> class uniform_real_distribution
    {
        T a;
        T b;

    public:
        uniform_real_distribution(T a, T b) : a(a), b(b) {}
        T operator()()
        {
            T lo = a;
            T hi = b;
            if (hi < lo)
            {
                T tmp = lo;
                lo = hi;
                hi = tmp;
            }
            return lo +
                   (hi - lo) *
                       (static_cast<T>(::rand()) / static_cast<T>(RAND_MAX));
        }
    };

    template <class T> class normal_distribution
    {
        T a;
        T b;

    public:
        normal_distribution(T a, T b) : a(a), b(b) {}
        T operator()()
        {
            return a +
                   (b - a) *
                       (static_cast<T>(::rand()) / static_cast<T>(RAND_MAX));
        }
    };

    template <class UIntType, UIntType a, UIntType c, UIntType m>
    class linear_congruential_engine
    {
        UIntType state;

    public:
        linear_congruential_engine(UIntType state) : state(state) {}
        UIntType operator()()
        {
            if (m == 0)
                state = a * state + c;
            else
                state = (a * state + c) % m;
            return state;
        }
    };
}

#endif
