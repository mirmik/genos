#ifndef GUARD_SINGLE_HEADER_HPP
#define GUARD_SINGLE_HEADER_HPP

// Single-file amalgamated header generated by make_one_header.sh
// Contains: macro.h, location.h, env.h, util.h, check.h, guard_main.h

// ===== Begin macro.h =====

#define GUARD_STRINGIFY(...) #__VA_ARGS__
// ===== End macro.h =====

// ===== Begin location.h =====

struct guard_location
{
    int line;
    const char *file;
    const char *func;
};

#define GUARD_CURRENT_LOCATION(name)                                           \
    struct guard_location name = {__LINE__, __FILE__, __func__};

#define GUARD_CURRENT_LOCATION_INITARGS __LINE__, __FILE__, __func__
// ===== End location.h =====

// ===== Begin env.h =====
// guard/check/env.h

#include <exception>
#include <string>

// Вся среда проверки в одной структуре
struct guard_check_env_t
{
std::string error_msg;
unsigned long long assert_total = 0;
unsigned long long assert_failed = 0;
};

// Глобальный (на процесс) экземпляр среды, реализованный через
// статическую локальную переменную внутри inline-функции
inline guard_check_env_t &guard_check_env()
{
    static guard_check_env_t env;
    return env;
}

// Макросы-алиасы, чтобы старый код продолжал работать как раньше
#define guard_check_error_msg (guard_check_env().error_msg)

// Начало "окружения" проверки: очищаем строку и запускаем try-блок
#define GUARD_CHECK_ENV_START()                                                \
    if (guard_check_error_msg.clear(), true)                                   \
        try

// Ветка обработки ошибки (после выброса guard_check_exception)
#define GUARD_CHECK_ENV_ERROR_HANDLER() catch (const guard_check_exception &)

// Установка сообщения об ошибке (перезаписывает предыдущий текст)
inline void GUARD_CHECK_ENV_RAISE_SET(const std::string &msg)
{
    guard_check_error_msg = msg;
}

// Переход назад в точку GUARD_CHECK_ENV_START()
class guard_check_exception : public std::exception
{
public:
    const char *what() const noexcept override
    {
        return "guard test failure";
    }
};
inline void GUARD_CHECK_ENV_RAISE_IMPL()
{
    throw guard_check_exception{};
}
inline void GUARD_CHECK_ENV_COUNT_ASSERT(bool success)
{
guard_check_env_t &env = guard_check_env();
++env.assert_total;
if (!success)
    ++env.assert_failed;
}

// Добавление сообщения об ошибке (для "мягких" CHECK)
inline void GUARD_CHECK_ENV_APPEND(const std::string &msg)
{
    if (!guard_check_error_msg.empty())
        guard_check_error_msg.push_back('\n');
    guard_check_error_msg += msg;
}

// ===== End env.h =====

// ===== Begin util.h =====

#include <cmath>
#include <limits>
#include <ostream>

namespace guard
{

    class Approx
    {
    public:
        explicit Approx(double value)
            : m_value(value), m_epsilon(1e-12), m_scale(1.0)
        {
        }

        // Задать относительную погрешность
        Approx &epsilon(double eps)
        {
            m_epsilon = eps;
            return *this;
        }

        // Задать масштаб (как в doctest / Catch2)
        Approx &scale(double s)
        {
            m_scale = s;
            return *this;
        }

        Approx operator()(double value) const
        {
            Approx copy = *this;
            copy.m_value = value;
            return copy;
        }

        double value() const
        {
            return m_value;
        }
        double epsilon() const
        {
            return m_epsilon;
        }
        double scale() const
        {
            return m_scale;
        }

        // Для отладочных сообщений
        friend std::ostream &operator<<(std::ostream &os, const Approx &a)
        {
            os << "Approx(" << a.m_value << ", eps=" << a.m_epsilon
               << ", scale=" << a.m_scale << ")";
            return os;
        }

        // Сравнение "число == Approx(...)"
        friend bool operator==(double lhs, const Approx &rhs)
        {
            return rhs.compare(lhs);
        }

        friend bool operator==(const Approx &lhs, double rhs)
        {
            return lhs.compare(rhs);
        }

        friend bool operator!=(double lhs, const Approx &rhs)
        {
            return !rhs.compare(lhs);
        }

        friend bool operator!=(const Approx &lhs, double rhs)
        {
            return !lhs.compare(rhs);
        }

    private:
        bool compare(double other) const
        {
            const double diff = std::fabs(other - m_value);
            const double tolerance = m_epsilon * (m_scale + std::fabs(m_value));
            return diff <= tolerance;
        }

        double m_value;
        double m_epsilon;
        double m_scale;
    };

}

// ===== End util.h =====

// ===== Begin check.h =====
// guard/check.h
#ifndef GUARD_CHECK_H
#define GUARD_CHECK_H


#include <sstream>
#include <string>

static inline std::string guard_location_part(struct guard_location loc)
{
    std::ostringstream os;
    os << "Error checked in location \n"
       << "\tline:" << loc.line << "\n"
       << "\tfile:" << loc.file << "\n"
       << "\tfunc:" << loc.func << "\n";
    return os.str();
}

// Базовый CHECK: выражение должно быть истинным (мягкий, не рвёт тест)
#define GUARD_CHECK(expr)                                                      \
    do                                                                         \
    {                                                                          \
        const bool _guard_ok = static_cast<bool>(expr);                        \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc)                              \
                      << "\tcond:" << GUARD_STRINGIFY(expr) << "\n\f";         \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
        }                                                                      \
    } while (0)

// Базовый REQUIRE: выражение должно быть истинным (жёсткий, рвёт тест)
#define GUARD_REQUIRE(expr)                                                    \
    do                                                                         \
    {                                                                          \
        const bool _guard_ok = static_cast<bool>(expr);                        \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc)                              \
                      << "\tcond:" << GUARD_STRINGIFY(expr) << "\n\f";         \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
            GUARD_CHECK_ENV_RAISE_IMPL();                                      \
        }                                                                      \
    } while (0)

// CHECK_FALSE: выражение должно быть ложным (мягкий)
#define GUARD_CHECK_FALSE(expr)                                                \
    do                                                                         \
    {                                                                          \
        const bool _guard_ok = !(expr);                                        \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond: !"               \
                      << GUARD_STRINGIFY(expr) << "\n\f";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
        }                                                                      \
    } while (0)

// REQUIRE_FALSE: выражение должно быть ложным (жёсткий)
#define GUARD_REQUIRE_FALSE(expr)                                              \
    do                                                                         \
    {                                                                          \
        const bool _guard_ok = !(expr);                                        \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond: !"               \
                      << GUARD_STRINGIFY(expr) << "\n\f";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
            GUARD_CHECK_ENV_RAISE_IMPL();                                      \
        }                                                                      \
    } while (0)

// Равенство: a == b (мягкий)
#define GUARD_CHECK_EQ(a, b)                                                   \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a == _guard_b);                         \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " == " GUARD_STRINGIFY(b) << "\n"  \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
        }                                                                      \
    } while (0)

// Равенство: a == b (жёсткий)
#define GUARD_REQUIRE_EQ(a, b)                                                 \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a == _guard_b);                         \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " == " GUARD_STRINGIFY(b) << "\n"  \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
            GUARD_CHECK_ENV_RAISE_IMPL();                                      \
        }                                                                      \
    } while (0)

// Неравенство: a != b (мягкий)
#define GUARD_CHECK_NEQ(a, b)                                                  \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a != _guard_b);                         \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " != " GUARD_STRINGIFY(b) << "\n"  \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
        }                                                                      \
    } while (0)

// Неравенство: a != b (жёсткий)
#define GUARD_REQUIRE_NEQ(a, b)                                                \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a != _guard_b);                         \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " != " GUARD_STRINGIFY(b) << "\n"  \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
            GUARD_CHECK_ENV_RAISE_IMPL();                                      \
        }                                                                      \
    } while (0)

// Меньше: a < b (мягкий)
#define GUARD_CHECK_LT(a, b)                                                   \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a < _guard_b);                          \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " < " GUARD_STRINGIFY(b) << "\n"   \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
        }                                                                      \
    } while (0)

// Меньше: a < b (жёсткий)
#define GUARD_REQUIRE_LT(a, b)                                                 \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a < _guard_b);                          \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " < " GUARD_STRINGIFY(b) << "\n"   \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
            GUARD_CHECK_ENV_RAISE_IMPL();                                      \
        }                                                                      \
    } while (0)

// Больше: a > b (мягкий)
#define GUARD_CHECK_GT(a, b)                                                   \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a > _guard_b);                          \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " > " GUARD_STRINGIFY(b) << "\n"   \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
        }                                                                      \
    } while (0)

// Больше: a > b (жёсткий)
#define GUARD_REQUIRE_GT(a, b)                                                 \
    do                                                                         \
    {                                                                          \
        const auto &_guard_a = (a);                                            \
        const auto &_guard_b = (b);                                            \
        const bool _guard_ok = (_guard_a > _guard_b);                          \
        GUARD_CHECK_ENV_COUNT_ASSERT(_guard_ok);                               \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_CURRENT_LOCATION(loc);                                       \
            std::ostringstream _guard_os;                                      \
            _guard_os << guard_location_part(loc) << "\tcond:"                 \
                      << GUARD_STRINGIFY(a) " > " GUARD_STRINGIFY(b) << "\n"   \
                      << "\tleft: " << _guard_a << "\n"                        \
                      << "\tright: " << _guard_b << "\n";                      \
            GUARD_CHECK_ENV_APPEND(_guard_os.str());                           \
            GUARD_CHECK_ENV_RAISE_IMPL();                                      \
        }                                                                      \
    } while (0)

#endif // GUARD_CHECK_H

// ===== End check.h =====

// ===== Begin guard_main.h =====
// guard.h (или guard/test.h)

#include <algorithm>
#include <map>

#include <chrono>
#include <cstring>
#include <exception>
#include <iostream>
#include <string>
#include <vector>

namespace guard::detail
{
    enum class Color
    {
        Default,
        Green,
        Red,
        Yellow
    };

    inline const char *color_code(Color c)
    {
#ifdef GUARD_TEST_ENABLE_COLORS
        switch (c)
        {
        case Color::Green:
            return "\033[32m";
        case Color::Red:
            return "\033[31m";
        case Color::Yellow:
            return "\033[33m";
        case Color::Default:
        default:
            return "\033[0m";
        }
#else
        (void)c;
        return "";
#endif
    }

    struct ColorScope
    {
        std::ostream &os;

        explicit ColorScope(std::ostream &os_, Color c) : os(os_)
        {
            os << color_code(c);
        }

        ~ColorScope()
        {
            os << color_code(Color::Default);
        }
    };
} // namespace guard::detail
namespace guard::test
{
    using TestFunc = void (*)();

    struct TestCase
    {
        const char *name;
        const char *file;
        int line;
        TestFunc func;
    };

    inline std::vector<TestCase> &registry()
    {
        static std::vector<TestCase> instance;
        return instance;
    }

    struct Registrar
    {
        Registrar(const char *name, const char *file, int line, TestFunc func)
        {
            registry().push_back(TestCase{name, file, line, func});
        }
    };

    struct RunnerStats
    {
        int total = 0;
        int passed = 0;
        int failed = 0;
    };
    struct ModuleStats
    {
        std::string file;
        int tests_total = 0;
        int tests_passed = 0;
        int tests_failed = 0;
        unsigned long long asserts_total = 0;
        unsigned long long asserts_failed = 0;
    };

    // test_filter == nullptr -> запускать все тесты
    inline int run_all(const char *test_filter, std::ostream &os = std::cout)
    {
        RunnerStats stats;
        std::map<std::string, ModuleStats> modules;

        using guard::detail::Color;
        using guard::detail::ColorScope;

        struct TestSummary
        {
            const TestCase *tc;
            std::string error;
            std::string stdout_output;
        };

        std::vector<TestSummary> failures;

        // Копируем и сортируем тесты по файлу, строке и имени
        auto tests = registry();
        std::sort(tests.begin(), tests.end(), [](const TestCase &lhs, const TestCase &rhs) {
            const std::string lhs_file(lhs.file ? lhs.file : "");
            const std::string rhs_file(rhs.file ? rhs.file : "");
            if (lhs_file < rhs_file)
                return true;
            if (rhs_file < lhs_file)
                return false;
            if (lhs.line != rhs.line)
                return lhs.line < rhs.line;
            const std::string lhs_name(lhs.name ? lhs.name : "");
            const std::string rhs_name(rhs.name ? rhs.name : "");
            return lhs_name < rhs_name;
        });

        for (const auto &tc : tests)
        {
            if (test_filter &&
                std::string(tc.name).find(test_filter) == std::string::npos)
                continue;

            ++stats.total;

            auto &mod = modules[tc.file];
            if (mod.file.empty())
                mod.file = tc.file;
            ++mod.tests_total;

            guard_check_error_msg.clear();

            guard_check_env_t &env = guard_check_env();
            const auto asserts_before_total = env.assert_total;
            const auto asserts_before_failed = env.assert_failed;

            bool test_passed = true;
            std::string test_error;

            // Перехватываем std::cout на время выполнения теста
            std::ostringstream captured_stdout;
            struct CoutRedirect
            {
                std::ostream &os;
                std::streambuf *old_buf;

                CoutRedirect(std::ostream &os_, std::streambuf *new_buf)
                    : os(os_), old_buf(os_.rdbuf(new_buf))
                {
                }

                ~CoutRedirect()
                {
                    os.rdbuf(old_buf);
                }
            } _guard_cout_redirect(std::cout, captured_stdout.rdbuf());

            GUARD_CHECK_ENV_START()
            {
                try
                {
                    tc.func();

                    if (guard_check_error_msg.empty())
                    {
                        ++stats.passed;
                        ++mod.tests_passed;
                        test_passed = true;
                    }
                    else
                    {
                        ++stats.failed;
                        ++mod.tests_failed;
                        test_passed = false;
                        test_error = guard_check_error_msg;
                    }
                }
                catch (const guard_check_exception &)
                {
                    // REQUIRE/FAIL бросают guard_check_exception — пробрасываем наружу
                    throw;
                }
                catch (const std::exception &ex)
                {
                    std::string msg =
                        std::string("Unexpected std::exception in test \"") +
                        tc.name + "\": " + ex.what();
                    GUARD_CHECK_ENV_RAISE_SET(msg);
                    GUARD_CHECK_ENV_RAISE_IMPL();
                }
                catch (...)
                {
                    std::string msg =
                        std::string("Unexpected non-std exception in test \"") +
                        tc.name + "\"";
                    GUARD_CHECK_ENV_RAISE_SET(msg);
                    GUARD_CHECK_ENV_RAISE_IMPL();
                }
            }
            GUARD_CHECK_ENV_ERROR_HANDLER()
            {
                ++stats.failed;
                ++mod.tests_failed;
                test_passed = false;
                if (!guard_check_error_msg.empty())
                    test_error = guard_check_error_msg;
            }

            const auto asserts_after_total = env.assert_total;
            const auto asserts_after_failed = env.assert_failed;
            mod.asserts_total += (asserts_after_total - asserts_before_total);
            mod.asserts_failed += (asserts_after_failed - asserts_before_failed);

            if (!test_passed)
            {
                failures.push_back(TestSummary{
                    &tc,
                    std::move(test_error),
                    captured_stdout.str()});
            }
        }

        os << "=======================\n";
        os << "Per-module summary:\n";
        for (const auto &entry : modules)
        {
            const auto &mod = entry.second;

            Color mod_color =
                (mod.tests_failed > 0 || mod.asserts_failed > 0)
                    ? Color::Red
                    : Color::Green;

            {
                ColorScope scope(os, mod_color);
                os << mod.file << ":\n";
            }

            os << "  Tests   : " << mod.tests_total
               << " (passed " << mod.tests_passed
               << ", failed " << mod.tests_failed << ")\n";
            os << "  Asserts : " << mod.asserts_total;
            if (mod.asserts_failed > 0)
                os << " (failed " << mod.asserts_failed << ")";
            os << "\n";
        }

        guard_check_env_t &env = guard_check_env();
        os << "=======================\n";
        {
            ColorScope summary_scope(os, stats.failed == 0 ? Color::Green : Color::Red);

            os << "Overall summary:\n";

            os << "Tests run : " << stats.total << "\n";

            os << "Passed    : ";
            {
                ColorScope passed_scope(os, stats.passed > 0 ? Color::Green : Color::Default);
                os << stats.passed;
            }
            os << "\n";

            os << "Failed    : ";
            {
                ColorScope failed_scope(os, stats.failed > 0 ? Color::Red : Color::Default);
                os << stats.failed;
            }
            os << "\n";
        }
        os << "Asserts   : " << env.assert_total
           << " (failed " << env.assert_failed << ")\n";

        os << "=======================\n";
        {
            ColorScope scope(os, failures.empty() ? Color::Green : Color::Red);
            os << "Failures detail:\n";
        }
        if (failures.empty())
        {
            os << "No test failures.\n";
        }
        else
        {
            for (const auto &f : failures)
            {
                {
                    ColorScope scope(os, Color::Red);
                    os << f.tc->file << ":" << f.tc->line
                       << " in test \"" << f.tc->name << "\"\n";
                }
                if (!f.error.empty())
                    os << f.error << "\n";
                if (!f.stdout_output.empty())
                {
                    os << "Captured stdout:\n";
                    os << f.stdout_output << "\n";
                }
                os << "-----------------------\n";
            }
        }

        return stats.failed ? 1 : 0;
    }

    inline int run_all(std::ostream &os = std::cout)
    {
        return run_all(nullptr, os);
    }
} // namespace guard::test

// ---------- внутренняя склейка имён ----------
#define GUARD_TEST_CONCAT_IMPL(a, b) a##b
#define GUARD_TEST_CONCAT(a, b) GUARD_TEST_CONCAT_IMPL(a, b)

// ---------- PUBLIC API: TEST_CASE ----------
//
// TEST_CASE("name") {
//     CHECK(...);
// }
#define TEST_CASE(name)                                                        \
    static void GUARD_TEST_CONCAT(guard_test_func_, __LINE__)();               \
    static ::guard::test::Registrar GUARD_TEST_CONCAT(guard_test_reg_,         \
                                                      __LINE__)(               \
        name,                                                                  \
        __FILE__,                                                              \
        __LINE__,                                                              \
        &GUARD_TEST_CONCAT(guard_test_func_, __LINE__));                       \
    static void GUARD_TEST_CONCAT(guard_test_func_, __LINE__)()

// ---------- Алисы CHECK* / REQUIRE* на GUARD_* ----------

#ifndef GUARD_TEST_NO_CHECK_ALIASES
#define CHECK(...) GUARD_CHECK(__VA_ARGS__)
#define CHECK_FALSE(expr) GUARD_CHECK_FALSE(expr)
#define CHECK_EQ(a, b) GUARD_CHECK_EQ(a, b)
#define CHECK_NEQ(a, b) GUARD_CHECK_NEQ(a, b)
#define CHECK_LT(a, b) GUARD_CHECK_LT(a, b)
#define CHECK_GT(a, b) GUARD_CHECK_GT(a, b)

#define REQUIRE(...) GUARD_REQUIRE(__VA_ARGS__)
#define REQUIRE_FALSE(expr) GUARD_REQUIRE_FALSE(expr)
#define REQUIRE_EQ(a, b) GUARD_REQUIRE_EQ(a, b)
#define REQUIRE_NEQ(a, b) GUARD_REQUIRE_NEQ(a, b)
#define REQUIRE_LT(a, b) GUARD_REQUIRE_LT(a, b)
#define REQUIRE_GT(a, b) GUARD_REQUIRE_GT(a, b)
#define FAIL(msg) GUARD_TEST_FAIL_MSG(msg)
#endif

// ---------- общий helper для "сделать фейл" ----------
#define GUARD_TEST_FAIL_MSG(msg_)                                              \
    do                                                                         \
    {                                                                          \
        GUARD_CHECK_ENV_COUNT_ASSERT(false);                                   \
        std::string _guard_msg = std::string("Test assertion failed at ") +    \
                                 __FILE__ + ":" + std::to_string(__LINE__) +   \
                                 ": " + (msg_);                                \
        GUARD_CHECK_ENV_APPEND(_guard_msg);                                    \
        GUARD_CHECK_ENV_RAISE_IMPL();                                          \
    } while (0)

// ---------- проверки исключений ----------

// ожидаем любое исключение (фатальный, ближе к REQUIRE_THROWS)
#define CHECK_THROWS(code)                                                     \
    do                                                                         \
    {                                                                          \
        bool _guard_thrown = false;                                            \
        try                                                                    \
        {                                                                      \
            code;                                                              \
        }                                                                      \
        catch (...)                                                            \
        {                                                                      \
            _guard_thrown = true;                                              \
        }                                                                      \
        if (!_guard_thrown)                                                    \
        {                                                                      \
            GUARD_TEST_FAIL_MSG(std::string("Expected exception from: ") +     \
                                #code);                                        \
        }                                                                      \
        else                                                                   \
        {                                                                      \
            GUARD_CHECK_ENV_COUNT_ASSERT(true);                                \
        }                                                                      \
    } while (0)

// ожидаем, что code кинет исключение типа ExType (фатальный)
#define CHECK_THROWS_AS(code, ExType)                                          \
    do                                                                         \
    {                                                                          \
        bool _guard_ok = false;                                                \
        try                                                                    \
        {                                                                      \
            code;                                                              \
        }                                                                      \
        catch (const ExType &)                                                 \
        {                                                                      \
            _guard_ok = true;                                                  \
        }                                                                      \
        catch (...)                                                            \
        {                                                                      \
        }                                                                      \
        if (!_guard_ok)                                                        \
        {                                                                      \
            GUARD_TEST_FAIL_MSG(std::string("Expected exception of type ") +   \
                                #ExType + " from: " #code);                    \
        }                                                                      \
        else                                                                   \
        {                                                                      \
            GUARD_CHECK_ENV_COUNT_ASSERT(true);                                \
        }                                                                      \
    } while (0)

// ожидаем, что code НИЧЕГО не кидает (фатальный)
#define CHECK_NOTHROW(code)                                                    \
    do                                                                         \
    {                                                                          \
        try                                                                    \
        {                                                                      \
            code;                                                              \
        }                                                                      \
        catch (const std::exception &_ex)                                      \
        {                                                                      \
            GUARD_TEST_FAIL_MSG(                                               \
                std::string("Unexpected std::exception from: ") + #code +      \
                ", what(): " + _ex.what());                                    \
        }                                                                      \
        catch (...)                                                            \
        {                                                                      \
            GUARD_TEST_FAIL_MSG(                                               \
                std::string("Unexpected non-std exception from: ") + #code);   \
        }                                                                      \
        GUARD_CHECK_ENV_COUNT_ASSERT(true);                                    \
    } while (0)

// ---------- "таймаут" по времени выполнения ----------
#define CHECK_TIMEOUT(code, ms)                                                \
    do                                                                         \
    {                                                                          \
        auto _guard_start = std::chrono::steady_clock::now();                  \
        code;                                                                  \
        auto _guard_end = std::chrono::steady_clock::now();                    \
        auto _guard_ms =                                                       \
            std::chrono::duration_cast<std::chrono::milliseconds>(             \
                _guard_end - _guard_start)                                     \
                .count();                                                      \
        if (_guard_ms > (ms))                                                  \
        {                                                                      \
            GUARD_TEST_FAIL_MSG(                                               \
                std::string("Timeout: expression ") + #code + " took " +       \
                std::to_string(_guard_ms) + " ms, limit is " +                 \
                std::to_string(static_cast<long long>(ms)) + " ms");           \
        }                                                                      \
        else                                                                   \
        {                                                                      \
            GUARD_CHECK_ENV_COUNT_ASSERT(true);                                \
        }                                                                      \
    } while (0)

// ---------- удобный main ----------
// Поддержка фильтрации тестов по имени через аргумент командной строки:
//   --test-case=NameSubstring
//   --test-case NameSubstring
#define GUARD_TEST_MAIN()                                                      \
    int main(int argc, char **argv)                                            \
    {                                                                          \
        const char *test_filter = nullptr;                                     \
        for (int i = 1; i < argc; ++i)                                         \
        {                                                                      \
            const char *arg = argv[i];                                         \
            const char prefix[] = "--test-case=";                              \
            if (std::strncmp(arg, prefix, sizeof(prefix) - 1) == 0)            \
            {                                                                  \
                test_filter = arg + sizeof(prefix) - 1;                        \
            }                                                                  \
            else if (std::strcmp(arg, "--test-case") == 0 && i + 1 < argc)     \
            {                                                                  \
                test_filter = argv[++i];                                       \
            }                                                                  \
        }                                                                      \
        return ::guard::test::run_all(test_filter);                            \
    }

// ===== End guard_main.h =====

#endif // GUARD_SINGLE_HEADER_HPP
